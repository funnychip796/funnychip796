# 二、CPU资源和存储器

需要访问的硬件资源主要有：CPU内部资源、存储器和I/O端口。

## 1、寄存器组

### （1）16位寄存器组

16位CPU所含有的寄存器有(见图2.1中16位寄存器部分)：
4个数据寄存器(AX、BX、CX和DX)
2个变址和指针寄存器(SI和DI)
2个指针寄存器(SP和BP)
4个段寄存器(ES、CS、SS和DS)
1个指令指针寄存器(IP)
1个标志寄存器(Flags)

### （2）32位寄存器组

32位CPU除了包含了先前CPU的所有寄存器，并把通用寄存器、指令指针和标志寄存器从16位扩充成32位之外，还增加了2个16位的段寄存器：FS和GS。
32位CPU所含有的寄存器有(见图2.1中的寄存器)：
4个数据寄存器(EAX、EBX、ECX和EDX)
2个变址和指针寄存器(ESI和EDI)
2个指针寄存器(ESP和EBP)
6个段寄存器(ES、CS、SS、DS、FS和GS)
1个指令指针寄存器(EIP)
1个标志寄存器(EFlags)

![](https://img2018.cnblogs.com/blog/1035094/201810/1035094-20181002210605319-909394832.jpg)

### （3）通用寄存器的作用

表2.1 通用寄存器的主要用途

![](https://img2018.cnblogs.com/blog/1035094/201810/1035094-20181002210605970-1909491598.png)

### （4）专用寄存器的作用

16位CPU内部有一个16位的标志寄存器，它包含9个标志位。这些标志位主要用来反映处理器的状态和运算结果的某些特征。各标志位在标志寄存器内的分布如图2.2所示。

![](https://img2018.cnblogs.com/blog/1035094/201810/1035094-20181002210606511-1062957059.jpg)

上面9个标志位可分为二组：运算结果标志位(有背景色的标志位)和状态控制标志位。前者受算术运算和逻辑运算结果的影响，后者受一些控制指令执行的影响。

16位标志寄存器——共用了9个标志位，标志位的分布如下表所示。

![](https://img2018.cnblogs.com/blog/1035094/201810/1035094-20181002210606933-1377805149.jpg)

32位标志寄存器——32位CPU也把标志寄存器扩展到32位，记为EFLAGS。它新增加了四个控制标志位，它们是：IOPL、NT、RF和VM，这些标志位在实方式下不起作用。其它标志位的位置和作用与先前的完全相同。

其主要标志位的分布如下表所示：

![](https://img2018.cnblogs.com/blog/1035094/201810/1035094-20181002210607368-892497643.jpg)

有些指令的执行会改变标志位(如：算术运算指令等)，不同的指令会影响不同的标志位，有些指令的执行不改变任何标志位(如：MOV指令等)，有些指令的执行会受标志位的影响(如：条件转移指令等)，也有指令的执行不受其影响。

程序员要想熟练运用这些标志位，就必须掌握每个标志位的含义、每条指令的执行条件和执行结果对标志位的作用。

注意：虽然知道每个标志位在标志寄存器内的具体位置是有好处的，但通常情况下，没有这个必要。在使用后面的“条件转移指令”时，系统会自动引用相应标志位的值来决定是否需要“转移”的，所以，不必过分强调标志位在标志寄存器内的具体位置。

* * *

知识点补充：

## 一、运算结果标志位

### 1、进位标志CF(Carry Flag)

进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。

使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。

### 2、奇偶标志PF(Parity Flag)

奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。

利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。

### 3、辅助进位标志AF(Auxiliary Carry Flag)

在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：

(1)、在字操作时，发生低字节向高字节进位或借位时；
(2)、在字节操作时，发生低4位向高4位进位或借位时。

对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。

### 4、零标志ZF(Zero Flag)

零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。

### 5、符号标志SF(Sign Flag)

符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。

### 6、溢出标志OF(Overflow Flag)

溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。

## 二、状态控制标志位

状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。

### 1、追踪标志TF(Trap Flag)

当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。

指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其它办法来改变其值。

### 2、中断允许标志IF(Interrupt-enable Flag)

中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：

(1)、当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；

(2)、当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。

CPU的指令系统中也有专门的指令来改变标志位IF的值。

### 3、方向标志DF(Direction Flag)

方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第5.2.11节——字符串操作指令——中给出。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值。

## 三、32位标志寄存器增加的标志位

### 1、I/O特权标志IOPL(I/O Privilege Level)

I/O特权标志用两位二进制位来表示，也称为I/O特权级字段。该字段指定了要求执行I/O指令的特权级。如果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常。

### 2、嵌套任务标志NT(Nested Task)

嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下：

(1)、当NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作。（表示当前任务由JMP指令跳转）

(2)、当NT=1，通过任务转换实现中断返回。（表示当前系统任务通过CALL指令被其他系统任务调用调用）

### 3、重启动标志RF(Restart Flag)

重启动标志RF用来控制是否接受调试故障。规定：RF=0时，表示“接受”调试故障，否则拒绝之。在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1。

### 4、虚拟8086方式标志VM(Virtual 8086 Mode)

如果该标志的值为1，则表示处理机处于虚拟的8086方式下的工作状态，否则，处理机处于一般保护方式下的工作状态。

* * *

## 2、存储器的管理模式

### 16位微机的内存管理模式

#### （1）存储器的分段

我们知道：计算机的内存单元是以“字节”为最小单位进行线性编址的。为了标识每个存储单元，就给每个存储单元规定一个编号，此编号就是该存储单元的物理地址。

存储单元的物理地址是一个无符号的二进制数。但为了书写的简化，物理地址通常用十六进制来表示。

16位CPU内部有20根地址线，其编码区间为：00000H~0FFFFFH，所以，它可直接访问的物理空间为1M(220)字节。而16位CPU内部存放存储单元偏移量的寄存器（如：IP、SP、BP、SI、DI和BX等）都是16位，它们的编码范围仅为：00000H~0FFFFH。这样，如果用16位寄存器来访问内存的话，则只能访问内存的最低端的64K，其它的内存将无法访问。为了能用16位寄存器来有效地访问1M的存储空间，16位CPU采用了内存分段的管理模式，并引用段寄存器的概念。

16位微机把内存空间划分成若干个逻辑段，每个逻辑段的要求如下：

逻辑段的起始地址(通常简称为：段地址)必须是16的倍数，即最低4位二进制必须全为0；

逻辑段的最大容量为64K，这由16位寄存器的寻址空间所决定。

按上述规定，1M内存最多可分成64K个段，即65536个段(段之间相互重叠)，至少可分成16个相互不重叠的段。

图2.4是内存各逻辑段之间的分布情况示意图，其中有相连的段(如：C和D段)、不相连的段(如：A和B段)以及相互重叠的段(如：B和C段)。

这种存储器分段的内存管理方法不仅实现了用两个16位寄存器来访问1M的内存空间，而且对程序的重定位、浮动地址的编码和提高内存的利用率等方面都具有重要的实用价值。

![](https://img2018.cnblogs.com/blog/1035094/201810/1035094-20181002210607790-1249134946.jpg)

#### （2）物理地址的形成方式

由于规定段地址必须是16的倍数，所以，其值的一般形式为：XXXX0H，即：前16位二进制位是变化的，后四位是固定为0。鉴于段地址的这种特性，我们可以仅保存其前16位二进制来达到保存整个段地址，其后四位可通过“左移补0”来获得。

在确定了某个存储单元所属的内存段后，我们也只知道其所处内存位置的范围，还不能确定其具体位置。要想确定内存单元的具体位置，还必须知道该单元离该段地址有多远。我们通常把存储单元的实际地址与其所在段的段地址之间的距离称为段内偏移，也可称为有效地址(EA—Effective Address)或偏移量(Offset)等。有了段地址和偏移量，就能唯一地确定某一内存单元在存储器内的具体位置。

由此可见，存储单元的逻辑地址分为两部分：段地址和偏移量。由逻辑地址得到其物理地址(PA—Physical Address)的计算方法如下：

物理地址PA=段地址×16 + 偏移量

计算存储单元物理地址的公式可用“左移4位”和“加”运算来实现。图2.5是物理地址的计算示意图。

![](https://img2018.cnblogs.com/blog/1035094/201810/1035094-20181002210608293-1154839807.jpg)

对物理地址来说，当段地址变化时，只要对其偏移量进行相应的调整就可对应同一个物理地址，所以，同一个物理地址可有多个逻辑地址。如图2.6所示。

在汇编语言程序中，存储单元通常不是用其物理地址标识的，而是用其逻辑地址标识的。逻辑地址的段地址由段寄存器给出，偏移量可由寄存器(SI、DI、BP和BX等)给出，也可用符号地址或具体的数值给出。

#### （3）段寄存器的引用

段寄存器是因为对内存的分段管理而设置的。16位CPU有四个段寄存器，所以，其程序可同时访问四个不同含义的段。段寄存器及其偏移量的引用关系如图2.7所示。

![](https://img2018.cnblogs.com/blog/1035094/201810/1035094-20181002210608764-500085834.jpg)

段寄存器CS指向存放程序的内存段，IP是用来存放下条待执行的指令在该段的偏移量，把它们合在一起可在该内存段内取到下次要执行的指令。

段寄存器SS指向用于堆栈的内存段，SP是用来指向该堆栈的栈顶，把它们合在一起可访问栈顶单元。另外，当偏移量用到了指针寄存器BP，则其缺省的段寄存器也是SS，并且用BP可访问整个堆栈，不仅仅是只访问栈顶。

段寄存器DS指向数据段，ES指向附加段，在存取操作数时，二者之一和一个偏移量合并就可得到存储单元的物理地址。该偏移量可以是具体数值、符号地址和指针寄存器的值等之一，具体情况将由指令的寻址方式来决定。

通常，缺省的数据段寄存器是DS，只有一个例外，即：在进行串操作时，其目的地址的段寄存器规定为ES。当然，在一般指令中，我们还可以用强置前缀的方法来改变操作数的段寄存器。

一般情况下，段寄存器及其指针寄存器的引用关系如下表所示。表2.2中的“可选用的段寄存器”即是可以用强置说明这些段寄存器的值来作为其操作数地址的段地址。

表2.2 段寄存器及其指针寄存器的引用关系

![](https://img2018.cnblogs.com/blog/1035094/201810/1035094-20181002210609267-180645215.jpg)

由上表可以看出16位CPU在段寄存器的引用方面有如下规定：

- 取指令所用的段寄存器和偏移量一定是用CS和IP；
    
- 堆栈操作所用的段寄存器和偏移量一定是SS和SP；
    
- 串操作的目标操作数所用的段寄存器和偏移量一定是ES和DI；
    
- 其它情况，段寄存器除了其默认引用的寄存器外，还可以强行改变为其它段寄存器。
    

#### （4）存储单元的内容

上面，我们讲述了16位微机的内存管理及其相关知识，知道了内存单元物理地址的计算方法，这使我们能很容易地指定所要访问的存储单元。但存储单元里的内容是如何存放的呢？下面就能描述数值在内存的存放形式。

存储单元中所存放的二进制信息通常称为该存储单元的内容或值，并且规定：

- 一个字节的内容是该字节单元内存放的二进制信息；
    
- 一个字的内容是该字地址所指向的单元及其后继一个单元的内容拼接而成；
    
- 一个双字的内容是该字地址所指向的单元及其后继三个单元的内容拼接而成。
    

在拼接“字内容”时，我们按“高高低低”的原则来处理，即：高存储单元(地址大的存储单元)的值是“字内容”的高8位，低存储单元(地址小的存储单元)的值是“字内容”的低8位。在拼接“双字内容”时也是如此。

图2.8是一段内存单元存放数据的例子。

从图中可看出下列存储结果：

- 字节12340H、12341H的内容分别为：12H和34H等；
    
- 字12340H、12341H的内容分别为：3412H和5634H等；
    
- 双字12340H、12341H的内容分别为：78563412H和90785634H等。
    

![](https://img2018.cnblogs.com/blog/1035094/201810/1035094-20181002210609752-1922224615.jpg)

### 32位微机的内存管理模式

32位微机的内存存管理仍然采用“分段”的管理模式，存储器的逻辑地址同样由段地址和偏移量两部分组成。32位微机的内存管理与16位微机的有相同之处，也有不同之处，因为它提供了两种不同工作方式：实方式和保护方式。

#### 1、物理地址的计算方式

实方式：段地址仍然是16的倍数，每个段的最大容量仍为64K。段寄存器的值是段的起始地址，存储单元的物理地址仍为段寄存器的值乘16，再加上段内偏移量。在此方式下，32位微机的内存管理与16位微机是相一致的。

保护方式：段地址可以长达32位，其值可以不是16的倍数，每个段的最大容量可达4G。段寄存器的值是表示段地址的“选择器”(Selector)，用该“选择器”可从内存中得到一个32位的段地址，存储单元的物理地址就是该段地址加上段内偏移量，这与16位微机的物理地址计算完全不同。

#### 2、段寄存器的引用

32位CPU内有6个段寄存器，程序在某一时刻可访问6个不同的段。其段寄存器的值在不同的方式下具有不同的含义：

##### (1)在实方式下，段寄存器的值就是段地址；

##### (2)在保护方式下，段寄存器的值不是段地址，是段地址的“选择器”。它间接指出一个32位的段地址。

下面分别说明各段寄存器的用法和作用。

代码段寄存器：32位微机在取指令时，系统自动引用CS和EIP来取出下条指令。在实方式下，由于段的最大容量不超过64K，所以，EIP的高16位全为0，其效果相当于16位CPU中的IP。

堆栈段寄存器：32位微机在访问堆栈段时，总是引用堆栈段寄存器SS。但在不同的方式下其堆栈指针有所不同：

###### 1)、在实方式下，32位微机把ESP的低16位SP作为指向堆栈的指针，所以，我们可以认为栈顶单元是由SS和SP来指定的。这就与16位微机访问栈顶单元的方法相一致；

###### 2)、在保护方式下，堆栈指针可用32位的ESP和16位的SP。

数据段寄存器：DS是主要的数据段寄存器。通常情况下，它是除访问堆栈以外数据时的默认段寄存器。在某些串操作中，其目的操作数的段寄存器被指定为ES是另一个例外。

另外，段寄存器CS、SS、ES、FS和GS也都可以作为访问数据时的段寄存器，但它们必须用段超越前缀的方式在指令中直接写出。用这种方式会增加指令的长度，指令的执行时间也有所延长。

一般来说，程序频繁访问的数据段用DS来指向，不太经常访问的数据段可用ES、FS和GS等来指向。

##### 3、存储单元的内容

32位微机存储单元内容的存储格式与16位微机的完全一致，也都采用“高高低低”的原则来存放数据。